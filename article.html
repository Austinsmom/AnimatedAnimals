<!-- Main image 580x315 (optional) -->

Today we want to show you how the clever use of HTML, CSS3 sequenced animations, and SVG filters can bring to life one of the most unlikely (yet adorable) things to be seen on a webpage - animals.

This demo is somewhat experimental - animated SVG filters are not available for Internet Explorer or Firefox at the time of writing, so the jittery "squigglevision" effect can only be seen on Chrome.

The animations involved are also complex, so this tutorial will focus on the different techniques involved in creating each of these creatures and their life-like movements. It's up to you to let your creative juices flow and create unique and playful animated animals on your own.

With that said, let's get started!

<h2>Shaping the Animals</h2>

The demos use two different techniques for creating the shapes of the different body parts of the animals. The husky uses CSS border-radius properties, and the fox uses inline background SVG images, as the shapes are more complex.

<h3>The Markup</h3>

Both animals use nested HTML divs to group the body parts. The concept of grouping is important for creating life-like movements -- when the head moves, the eyes and ears should always move too, as they are attached to the head.

<pre class="brush:html"><code>
&lt;!-- Markup for the fox head --&gt;
&lt;div class="fox-head"&gt;
  &lt;div class="fox-face"&gt;            
    &lt;div class="fox-ears"&gt;
      &lt;div class="fox-ear"&gt;&lt;/div&gt;
      &lt;div class="fox-ear"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="fox-front"&gt;&lt;/div&gt;
    &lt;div class="fox-eyes"&gt;&lt;/div&gt;
    &lt;div class="fox-nose"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;!-- Markup for the husky head --&gt;
&lt;div class="husky-head"&gt;
  &lt;div class="husky-ear"&gt;&lt;/div&gt;
  &lt;div class="husky-ear"&gt;&lt;/div&gt;
  &lt;div class="husky-face"&gt;
    &lt;div class="husky-eye"&gt;&lt;/div&gt;
    &lt;div class="husky-eye"&gt;&lt;/div&gt;
    &lt;div class="husky-nose"&gt;&lt;/div&gt;
    &lt;div class="husky-mouth"&gt;
      &lt;div class="husky-lips"&gt;&lt;/div&gt;
      &lt;div class="husky-tongue"&gt;&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

Each part can move independently, and will move with its parent element as it does so, which creates a more realistic effect.

<h3>Shaping with CSS</h3>

The <code>border-radius</code> property is used heavily for shaping the husky with CSS. For many elements, individual control of each border radius was needed. For example, here is how the husky's hind leg was shaped:

<pre class="brush:scss"><code>
.husky-hind-leg {
  // ...
  border-top-left-radius: 35% 100%;
  border-top-right-radius: 40% 100%;
}
</code></pre>

Other shapes, such as the front legs, could not be shaped with <code>border-radius</code> alone, and needed to be shaped using <code>transform</code>:

<pre class="brush:css"><code>
.husky-front-legs &gt; .husky-leg:before {
  transform: skewY(-30deg) skewX(10deg);
  transform-origin: top right;
}
</code></pre>

<h3>Shaping with SVG</h3>

For the fox, <a href="https://github.com/davidkpiano/sass-svg">my Sass-SVG tool</a> was used to create the complex SVG shapes for each body part. SVG images can be <a href="https://css-tricks.com/using-svg/">used as background images</a>, and even better, they can be written inline as long as they are either base-64 or UTF-8 encoded (for maximum browser support). Writing them by hand is tricky though, so let's see how Sass-SVG makes it a little easier, using the fox's nose as an example:

<pre class="brush:scss"><code>
.fox-nose:before {
  @include svg((viewBox: (0 0 168 168))) {
    // the nose
    @include svg('path', (
      fill: $color-nose,
      d: 'M83.7,86.7c3.3,0,11.6-3.9,11.6-7.1c0-3.2-9.4-3.2-11.6-3.2c-2.2,0-11.6,0-11.6,3.2   C72.1,82.8,80.4,86.7,83.7,86.7z'
    ));

    // the line connecting the nose to the mouth
    @include svg('path', (
      stroke: $color-nose,
      fill: none,
      d: 'M83.7,102.3V86.7'
    ));

    // the mouth
    @include svg('path', (
      stroke: $color-nose,
      fill: none,
      d: 'M94.5,104.9c0,0-5.2-2.7-10.8-2.7c-5.6,0-10.8,2.7-10.8,2.7'
    ));
  }
}
</code></pre>

This will generate an encoded, inline SVG string inside of a `url()` that looks something like this:

<pre class="brush:scss"><code>
.fox-hose:before {
  background-image: url("data:image/svg+xml;charset=utf8,%3Csvg...");
}
</code></pre>

Since the SVG is a background image, it can be transformed and animated as if it were an HTML element. With Sass-SVG, Sass <code>$variables</code> can be used to have full control of the SVG <code>fill</code> and <code>stroke</code> colors.

<h2>"Squigglevision" with SVG Filters</h2>

<a href="https://en.wikipedia.org/wiki/Squigglevision">Squigglevision</a> is an animation technique that simulates hand-drawn animation by wiggling the outlines of a shape. This makes scenes, such as the fox and husky, seem more dynamic and sketched, even when the animals aren't moving.

SVG has a filter called <code>&lt;feTurbulence&gt;</code> that gives "noise" to whatever it's applied to. The <code>&lt;feDisplacementMap&gt;</code> filter is combined to specify how far away the pixels should move in each filter.

<pre class="brush:html"><code>
&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt;
  &lt;defs&gt;
    &lt;filter id="squiggly-0"&gt;
      &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="0"/&gt;
      &lt;feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="2" /&gt;
    &lt;/filter&gt;
    &lt;filter id="squiggly-1"&gt;
      &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="1"/&gt;
&lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="3" /&gt;
    &lt;/filter&gt;
    
    &lt;filter id="squiggly-2"&gt;
      &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="2"/&gt;
&lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="2" /&gt;
    &lt;/filter&gt;
    &lt;filter id="squiggly-3"&gt;
      &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="3"/&gt;
&lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="3" /&gt;
    &lt;/filter&gt;
    
    &lt;filter id="squiggly-4"&gt;
      &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="4"/&gt;
&lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="1" /&gt;
    &lt;/filter&gt;
  &lt;/defs&gt; 
&lt;/svg&gt;
</code></pre>

Each filter has slightly different attributes. These filters can be applied to any element using the CSS <code>filter: url(...);</code> property. To create the "squigglevision" effect, a keyframe animation sets one filter at a time in rapid succession.

<pre class="brush:css"><code>
@keyframes squigglevision {
  0% {
    -webkit-filter: url('#squiggly-0');
    filter: url('#squiggly-0');
  }
  25% {
    -webkit-filter: url('#squiggly-1');
    filter: url('#squiggly-1');
  }
  50% {
    -webkit-filter: url('#squiggly-2');
    filter: url('#squiggly-2');
  }
  75% {
    -webkit-filter: url('#squiggly-3');
    filter: url('#squiggly-3');
  }
  100% {
    -webkit-filter: url('#squiggly-4');
    filter: url('#squiggly-4');
  }
}
</code></pre>

<div class="box-attention">
<strong>Attention:</strong> These SVG filters do not seem to work in Firefox currently, so treat filter animations such as this one as a progressive enhancement.</strong>
</div>

<h2>Sequencing Animations</h2>

CSS keyframes do not provide us a convenient way of sequencing and composing animations. The best way to approach this problem is to plan (storyboard) your animation as a <strong>timeline</strong> and use a preprocessor such as Sass to generate the keyframes.

For the fox, transforms and absolute time offsets (seconds) were used to animate each body part after outlining the storyboard for when each animation should occur. Here's an example of how the fox's nose was outlined in SCSS:

<pre><code>
$animations: (
  // ...

  'nose': (
    // resting position
    (4s, 5s, 7s): rotateY(-4deg),

    // nose down
    4.5s: rotateY(-4deg) rotateX(-3deg),

    // fox looks left
    (7.5s, 9s): rotateX(-3deg) rotateY(-28deg) rotateZ(-11deg),

    // fox looks right
    (9.5s, 12s): rotateY(7deg),

    // fox looks straight ahead
    13s: rotateY(0),
  ),

  // ...
);
</code></pre>

Browser support icons shortcode:
[browsersupport chrome="all" safari="all" opera="all" firefox="flag" ie="9+"]
(If a browser is not supported at all, just leave it out)

